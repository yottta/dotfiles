export ZSH="$HOME/.oh-my-zsh"
export PATH="$PATH:/opt/local/bin:/opt/local/sbin"

### zsh & oh-my-zsh properties
# zsh
HISTSIZE=99999999
# oh-my-zsh
HIST_STAMPS="mm/dd/yyyy"
DISABLE_AUTO_TITLE="true"
export ZSH_COMPDUMP=$ZSH/cache/.zcompdump-$HOST
# 3rd party
ZSH_AUTOSUGGEST_STRATEGY=(history)

# PROMPT settings
git_info() {
  current_branch=`git branch --show-current` 2>/dev/null
  if [ $? -ne 0 ]; then
    return
  fi
  if [ -z $current_branch ]; then
    current_branch=`git branch -a | grep "*"`
    if [[ $current_branch == *"no branch"* ]]; then
      current_branch=`echo $current_branch | cut -d',' -f2 | sed 's/)//' | xargs`
    fi
  fi
  echo "%F{magenta}[%F{red}${current_branch}%F{magenta}]$reset_color "
}

k8s_info() {
  out="%F{white}( %F{blue}\u2638%b$reset_color %F{white}| "
  which kubectx > /dev/null
  if [ $? -ne 0 ]; then
    return
  fi
  kubectx -c > /dev/null 2>&1
  if [ $? -ne 0 ]; then
    return
  fi
  out="$out%F{cyan}`kubectx -c`"
  which kubens > /dev/null
  if [ $? -eq 0 ]; then
    out="$out:`kubens -c`"
  fi
  out="$out%F{white} ) "
  echo $out"$reset_color"
}

setopt PROMPT_SUBST
NEWLINE=$'\n'
# CUSTOM_NO_PROMPT="true"
if [ ! -z $CUSTOM_NO_PROMPT ]; then
  PROMPT='%#> '
else 
  PROMPT='%(?..[%?] )%F{green}%~$reset_color $(git_info)$reset_color$NEWLINE%#> '
fi

# plugins
# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)
# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
#
# For fzf:
# git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
# ~/.fzf/install
# Do not install 'timer' since that is customly configured below
# plugins=(timer fzf)
plugins=(fzf)

source $ZSH/oh-my-zsh.sh
source $ZSH/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh
autoload -U compinit && compinit

######### keybindings #########
# go one directory back - ctrl + k
function up_widget() {
  BUFFER="cd .."
  zle accept-line
}
zle -N up_widget
bindkey "^u" up_widget

# go to home directory - ctrl + h
function goto_home() {
  BUFFER="cd ~/"$BUFFER
  zle end-of-line
  zle accept-line
}
zle -N goto_home
bindkey "^h" goto_home

# add to current BUFFER the sudo keyword
function add_sudo() {
  BUFFER="sudo "$BUFFER
  zle end-of-line
}
zle -N add_sudo
bindkey "^s" add_sudo

export VISUAL=nvim
autoload edit-command-line
bindkey "^v" edit-command-line

###### Print start start time and end time plus duration for each command.
# This can be improved because right now the time that is used for start/end 
# is not the same with the one for the elapsed time.
strlen () {
    local in=$1
    local zero='%([BSUbfksu]|([FB]|){*})'
    local len=${#${(S%%)in//$~zero/}}
    echo $len
}
function preexec() {
  cmd_start=$(($(print -P %D{%s%6.}) / 1000))
  cmd_start_time=$(date +"%H:%M:%S")
}
function precmd() {
  if [ $cmd_start ]; then
    local now=$(($(print -P %D{%s%6.}) / 1000))
    local cmd_stop_time=$(date +"%H:%M:%S")
    local d_ms=$(($now - $cmd_start))
    local d_s=$((d_ms / 1000))
    local ms=$((d_ms % 1000))
    local s=$((d_s % 60))
    local m=$(((d_s / 60) % 60))
    local h=$((d_s / 3600))

    if   ((h > 0)); then cmd_time=${h}h${m}m
    elif ((m > 0)); then cmd_time=${m}m${s}s
    elif ((s > 9)); then cmd_time=${s}.$(printf %03d $ms | cut -c1-2)s # 12.34s
    elif ((s > 0)); then cmd_time=${s}.$(printf %03d $ms)s # 1.234s
    else cmd_time=${ms}ms
    fi
    local final_output="${cmd_start_time} -> ${cmd_stop_time} (${cmd_time})"

    local len_right=$( strlen "${final_output}" )
    local len_right=$(( $len_right+1 ))
    local right_start=$(($COLUMNS - $len_right))

    local final_date="\033[${right_start}C ${final_output}"
    echo -e "${final_date}"

    unset cmd_start
  else
    # Clear previous result when hitting Return with no command to execute
    unset cmd_time
  fi
}
###### Print start start time and end time plus duration for each command. (END)

# personal settings - also could overwrite the PROMPT variable. Search for "PROMPT=" in your dotfiles
[ -f ~/.common_system ] && . ~/.common_system
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

## This is left here only for future debugging whenever needs to get the elapsed time for a part of a script. This is for iOS since it's using gdate (brew install coreutils)
# start=$(gdate +%s%N)
# YOUR COMMAND HERE
# end=$(gdate +%s%N)
# echo "Elapsed Time for TOOL: $(($(($end-$start))/1000000)) ms"

# The next line updates PATH for the Google Cloud SDK.
if [ -f '/Users/andrei.ciobanu/data/workspace/softs/lib/google-cloud-sdk/path.zsh.inc' ]; then . '/Users/andrei.ciobanu/data/workspace/softs/lib/google-cloud-sdk/path.zsh.inc'; fi

# The next line enables shell command completion for gcloud.
if [ -f '/Users/andrei.ciobanu/data/workspace/softs/lib/google-cloud-sdk/completion.zsh.inc' ]; then . '/Users/andrei.ciobanu/data/workspace/softs/lib/google-cloud-sdk/completion.zsh.inc'; fi

# opencode
export PATH=/Users/andrei.ciobanu/.opencode/bin:$PATH
